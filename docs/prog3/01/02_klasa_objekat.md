# Класа и објекат

Објектно-оријентисано програмирање (ООП) је парадигма програмирања која користи
објекте као основу за пројектовање рачунарског софтвера. Решавање проблема
ООП парадигмом је врло слично људском начину размишљања и решавању реалних
проблема. Било који систем из реалног света може се посматрати као скуп
објеката који међусобно комуницирају.

**Класа** представља групу објеката који имају заједничке карактеристике и
функционалности - каже се да је класа апстрактна представа скупа објеката који
имају заједничке карактеристике и функционалности. **Објекат** представља
инстанцу класе, односно конкретан примерак класе. То значи да класу требаш
схватити као скицу, нацрт или шаблон на основу које се инстанцирају објекти.

## Мане структурираног програмирања

У програмском језику C могао си да декларишеш структуру `trougao` чији су
елементи реалне променљиве које представљају странице троугла, на пример:

```c
struct trougao {
    double a;
    double b;
    double c;
};
```

Ова структура сама по себи не садржи никакве податке о неком одређеном троуглу,
већ представља шаблон за дефинисање било ког троугла на основу дужине његових
страница. Ако декларишеш и иницијализујеш неку променљиву која је типа
структуре `trougao`, тек онда си дефинисао конкретан троугао. На пример, ако за
горе дефинисану структуру `trougao` декларишеш и иницијализујеш променљиву
`t1`...

```c
struct trougao t1 = { 3.0, 4.0, 5.0 };
```

...онда си дефинисао конкретан троугао `t1` чије су странице редом дужине
$a=3.0$, $b=4.0$ и $c=5.0$. То значи и да си за `t1` алоцирао простор у
статичкој меморији (на стеку) и у њега уписао вредности страница троугла. Ако
се прича о троугловима, вероватно би у свом програму требао да имаш и
функционалност за израчунавање обима троугла, његове површине, његових углова и
сл. То би у програмском језику C реализовао помоћу функција. На пример,
функција која рачуна обим троугла изгледала би овако...

```c
double obim(double a, double b, double c)
{
    return a + b + c;
}
```

...а њен позив и испис вредности у главном програму овако:

```c
printf("Obim trougla je: %lf", obim(t1.a, t1.b, t1.c));
```

Када би добио задатак да дати програм прошириш и на правоугаонике, дефинисао би
структуру `pravougaonik`, написао функције за израчунавање обима правоугаоника,
површине правоугаоника и др. Већ за овако једноставан задатак у коду би имао
две функције за рачунање обима - једну за троугао, другу за правоугаоник, па би
морао да им промениш имена у `obim_trougla()` и `obim_pravougaonika()`.

Замисли да треба да прошириш програм за више геометријских облика. На истом
месту појавиле би се функције којима се рачуна обим троугла, правоугаоника,
круга и др, иако ове функције међусобно немају никакве везе. Много времена би
изгубио у осмишљавању имена променљивих и функција, а што програм више расте,
било би ти теже да пратиш где се шта налази, како се шта зове итд. Још би ти
теже било да вршиш измене и допуне таквог програмског кода.

## Предности објектно-оријентисаног програмирања

Применом парадигме објектно-оријентисаног програмирања, овакви проблеми
нестају. Логично је да се све ствари везане за троугао налазе на једном месту,
у једном шаблону, односно у једној класи. За пример изнад, класу `Trougao`
можеш дефинисати на следећи начин...

```text
klasa Trougao
{
    promenljiva a;
    promenljiva b;
    promenljiva c;
    
    funkcija Obim()
    {
        vrati a + b + c;
    }
}
```

...па потом, у главном програму, инстанцирати један објекат класе `Trougao`,
позвати његову методу за израчунавање обима и исписати резултат:

```text
Trougao t1 = novi Trougao() { a = 3.0, b = 4.0, c = 5.0 };
Ispiši(t1.Obim());
```

Сада се комплетан кôд који се тиче троугла налази на једном месту - и
карактеристике и функционалност. Када би добио задатак да дати програм прошириш
и на правоугаонике, креирао би класу `Pravougaonik` у оквиру које би се налазио
комплетан кôд који се тиче правоугаоника. Све измене и допуне програма могао би
да вршиш једноставно, јер је увек јасно где се шта налази.

За разлику од променљивих и структура у програмском језику C, у већини ООП
језика за инстанциране објекте алоцира се динамичка меморија (на хипу).
